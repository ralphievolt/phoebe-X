#!/usr/bin/env node
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 6);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isDebug = exports.flattenOptions = exports.getRemainingOptions = exports.getRemainingVariables = exports.getEnvironmentVariable = exports.getEnvironmentVariables = exports.getArg = exports.getArgs = undefined;

var _yargs = __webpack_require__(8);

var _yargs2 = _interopRequireDefault(_yargs);

var _constants = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// returns all args as an yargs object
const getArgs = exports.getArgs = (argv = process.argv) => (0, _yargs2.default)(argv).argv;

// returns the arg based on name
const getArg = exports.getArg = (argName, argv = process.argv) => getArgs(argv)[argName];

// returns list of environment variables (-e flag)
// as an array of env objects [{ name: 'MONGO_URL', value: 'mongodb...' }]
const getEnvironmentVariables = exports.getEnvironmentVariables = () => {
  const args = getArg('e');
  if (!args) return null;
  const argsArray = args instanceof Array ? args : [args];
  return argsArray.map(e => {
    const envArray = e.split('=');
    let val = envArray[1];
    if (envArray.length > 2) {
      val = ['"', envArray.slice(1, envArray.length).join('='), '"'].join('');
    }
    return {
      name: envArray[0],
      value: val
    };
  });
};

// return a single env object
const getEnvironmentVariable = exports.getEnvironmentVariable = (name, args = getEnvironmentVariables()) => {
  if (!args) {
    return null;
  }
  const variable = args.find(e => e.name === name);
  return variable ? variable.value : null;
};

// get all variables except for MONGO_URL, ROOT_URL, METEOR_SETTINGS and PORT
// this is in case user passed additional environment variables to their app
// those would be passed down to the now cli command
const getRemainingVariables = exports.getRemainingVariables = (environmentVariables = getEnvironmentVariables()) => {
  if (!environmentVariables) {
    return [];
  }
  // filter our vars we already handled and return an array
  // where first value is the flag -e and second is the ENV=VALUE
  return environmentVariables.filter(v => _constants.ignoreVarsArray.indexOf(v.name) === -1).map(v => ['-e', `${v.name}=${v.value}`]);
};

// get remaining options that user has passsed to meteor-now
const getRemainingOptions = exports.getRemainingOptions = () => {
  const args = getArgs();
  console.log('args are ', args);
  return Object.entries(args)
  // filter out specified list of options
  .filter(arg => _constants.ignoreOptionsArray.indexOf(arg[0]) === -1)
  // filter out all environment variables
  .filter(arg => arg[0] !== 'e')
  // check if flag is of boolean type and just return flag name
  // yargs sets true if only flag was present without value
  .map(arg => {
    if (typeof arg[1] === 'boolean') {
      return [arg[0]];
    }
    return [arg[0], arg[1]];
  })
  // prefix flag names with either a single dash (-) or double (--) dash
  .map(arg => {
    const argWithPrefix = [...arg];
    if (arg[0].length > 1) {
      argWithPrefix[0] = `--${arg[0]}`;
    } else {
      argWithPrefix[0] = `-${arg[0]}`;
    }
    return argWithPrefix;
  });
};

// eslint-disable-next-line
const flattenOptions = exports.flattenOptions = options => [].concat.apply([], options);

// returns true if use passed in -d flag otherwise false
const isDebug = exports.isDebug = () => !!getArg('d');

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.logPrefix = exports.ignoreOptionsArray = exports.ignoreVarsArray = exports.tarFileName = exports.meteorNowBuildPath = exports.homePath = exports.projectName = exports.getFolderName = undefined;

var _os = __webpack_require__(9);

var _os2 = _interopRequireDefault(_os);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const isWin = /^win/.test(process.platform);

const getFolderName = exports.getFolderName = (path, isWinOverride = isWin) => {
  const pathDelimiter = isWinOverride ? '\\' : '/';
  const pathParts = path.split(pathDelimiter);
  return pathParts[pathParts.length - 1];
};

// run immediately
const projectName = exports.projectName = (() => getFolderName(process.cwd()))();
const homePath = exports.homePath = _os2.default.homedir();
const meteorNowBuildPath = exports.meteorNowBuildPath = isWin ? `${homePath}\\.meteor-now\\build` : `${homePath}/.meteor-now/build`;
const tarFileName = exports.tarFileName = `${projectName}.tar.gz`;
const ignoreVarsArray = exports.ignoreVarsArray = ['MONGO_URL', 'ROOT_URL', 'METEOR_SETTINGS', 'PORT'];
const ignoreOptionsArray = exports.ignoreOptionsArray = ['deps', '_', '$0', 'help', 'version', 'nosplit'];
const logPrefix = exports.logPrefix = '[METEOR-NOW] - ';

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _colors = __webpack_require__(10);

var _colors2 = _interopRequireDefault(_colors);

var _constants = __webpack_require__(1);

var _args = __webpack_require__(0);

var _spinner = __webpack_require__(11);

var _spinner2 = _interopRequireDefault(_spinner);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Logger {
  static info(message, ...rest) {
    if (!(0, _args.isDebug)()) {
      this.log('start', message, rest);
    } else {
      this.debug(message);
    }
  }
  static debug(message, ...rest) {
    if ((0, _args.isDebug)()) {
      this.log('info', message, rest);
    }
  }
  static warn(message, ...rest) {
    this.log('warn', _colors2.default.yellow(message), rest);
  }
  static error(message, ...rest) {
    this.log('fail', _colors2.default.red(message), rest);
  }
  static succeed(message, ...rest) {
    if (!(0, _args.isDebug)()) {
      this.log('succeed', message, rest);
    }
  }
  static log(type, message, rest) {
    const restOfMessage = [...rest][0] && rest.join(' ');
    const prefixed = `${_constants.logPrefix}${message} ${!restOfMessage ? '' : restOfMessage}`;
    if (type === 'succeed') {
      _spinner2.default.succeed();
    } else {
      _spinner2.default[type](prefixed);
    }
  }
}
exports.default = Logger;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMeteorSettings = exports.buildMeteorApp = exports.shouldBeServerOnly = exports.getMicroVersion = exports.getVersion = undefined;

var _process = __webpack_require__(5);

var _process2 = _interopRequireDefault(_process);

var _constants = __webpack_require__(1);

var _files = __webpack_require__(4);

var _args = __webpack_require__(0);

var _logger = __webpack_require__(2);

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

// get the full meteor release version
const getVersion = exports.getVersion = (() => {
  var _ref = _asyncToGenerator(function* () {
    const release = yield (0, _files.readFile)('.meteor/release');
    return release.match(/METEOR@(.*)\r?\n/)[1];
  });

  return function getVersion() {
    return _ref.apply(this, arguments);
  };
})();

// get the minor version number of the meteor release
const getMicroVersion = exports.getMicroVersion = (() => {
  var _ref2 = _asyncToGenerator(function* () {
    const version = yield getVersion();
    return version.split('.')[1];
  });

  return function getMicroVersion() {
    return _ref2.apply(this, arguments);
  };
})();

// check to see if server only flag should be
// passed to meteor build
const shouldBeServerOnly = exports.shouldBeServerOnly = () => {
  if (parseInt(getMicroVersion(), 10) < 3) {
    return false;
  }
  return true;
};

// build the meteor app by using meteor build
const buildMeteorApp = exports.buildMeteorApp = (() => {
  var _ref3 = _asyncToGenerator(function* () {
    try {
      _logger2.default.info('Building meteor app (this can take several minutes)');
      yield (0, _process2.default)('meteor', ['build', _constants.meteorNowBuildPath, shouldBeServerOnly() ? '--server-only' : '', '--architecture=os.linux.x86_64']);
      _logger2.default.succeed();
    } catch (e) {
      // eslint-disable-next-line
      _logger2.default.error(e);
    }
  });

  return function buildMeteorApp() {
    return _ref3.apply(this, arguments);
  };
})();

// get meteor settings by checking for settings.json files
// uses NODE_ENV to determine which settings file to load
const getMeteorSettings = exports.getMeteorSettings = (() => {
  var _ref4 = _asyncToGenerator(function* () {
    const nodeEnv = (0, _args.getEnvironmentVariable)('NODE_ENV');
    if (nodeEnv) {
      const settingsFilePath = `${nodeEnv}.settings.json`;
      try {
        const settingsFile = yield (0, _files.readFile)(settingsFilePath);
        return settingsFile.replace(/\r?\n|\r/g, '');
      } catch (e) {
        throw e;
      }
    }
    return null;
  });

  return function getMeteorSettings() {
    return _ref4.apply(this, arguments);
  };
})();

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clearBuildFolder = exports.prepareBundle = exports.renameFile = exports.deletePath = exports.writeFile = exports.readFile = undefined;

var _fileSystem = __webpack_require__(14);

var _fileSystem2 = _interopRequireDefault(_fileSystem);

var _splitFile = __webpack_require__(15);

var _splitFile2 = _interopRequireDefault(_splitFile);

var _del = __webpack_require__(16);

var _del2 = _interopRequireDefault(_del);

var _logger = __webpack_require__(2);

var _logger2 = _interopRequireDefault(_logger);

var _constants = __webpack_require__(1);

var _args = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const encoding = 'utf8';

const readFile = exports.readFile = path => _fileSystem2.default.readFileSync(path, encoding);
const writeFile = exports.writeFile = (path, data) => _fileSystem2.default.writeFileSync(path, data, encoding);
const deletePath = exports.deletePath = path => (0, _del2.default)(path, { force: true });
const renameFile = exports.renameFile = (oldPath, newPath) => _fileSystem2.default.renameSync(oldPath, newPath);

// split meteor bundle into pieces
const prepareBundle = exports.prepareBundle = (() => {
  var _ref = _asyncToGenerator(function* () {
    const bundlePath = `${_constants.meteorNowBuildPath}/${_constants.tarFileName}`;
    try {
      if ((0, _args.getArg)('nosplit')) {
        renameFile(bundlePath, `${_constants.meteorNowBuildPath}/bundle.tar.gz`);
      } else {
        _logger2.default.debug('splitting bundle');
        yield _splitFile2.default.splitFileBySize(`${_constants.meteorNowBuildPath}/${_constants.tarFileName}`, 999999);
        yield deletePath(bundlePath);
      }
    } catch (e) {
      _logger2.default.error(e);
    }
  });

  return function prepareBundle() {
    return _ref.apply(this, arguments);
  };
})();

const clearBuildFolder = exports.clearBuildFolder = () => {
  _logger2.default.debug('clearing build folder');
  return deletePath(_constants.meteorNowBuildPath);
};

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _child_process = __webpack_require__(7);

var _args = __webpack_require__(0);

var _logger = __webpack_require__(2);

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (cmd, args) => {
  _logger2.default.debug(`$ ${cmd}`, ...args);
  return new Promise((resolve, reject) => {
    const child = (0, _child_process.spawn)(cmd, args, {
      stdio: (0, _args.isDebug)() ? 'inherit' : [process.stdin, 'pipe', process.stderr],
      shell: true
    });

    child.on('exit', (code, signal) => {
      if (code !== 0) {
        reject({ code, signal });
      } else {
        resolve();
      }
    });

    if (child.stdout) {
      child.stdout.on('data', data => {
        resolve(data.toString());
      });
    }
  });
};

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _meteor = __webpack_require__(3);

var _docker = __webpack_require__(17);

var _files = __webpack_require__(4);

var _now = __webpack_require__(18);

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const main = (() => {
  var _ref = _asyncToGenerator(function* () {
    yield (0, _files.clearBuildFolder)();
    yield (0, _meteor.buildMeteorApp)();
    yield (0, _docker.prepareDockerConfig)();
    yield (0, _files.prepareBundle)();
    yield (0, _now.deploy)();
  });

  return function main() {
    return _ref.apply(this, arguments);
  };
})();

main();

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = require("child_process");

/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = require("yargs");

/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports = require("os");

/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = require("colors");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ora = __webpack_require__(12);

var _ora2 = _interopRequireDefault(_ora);

var _cliSpinners = __webpack_require__(13);

var _cliSpinners2 = _interopRequireDefault(_cliSpinners);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Spinner extends _ora2.default {
  constructor() {
    super();
    this.spinner = _cliSpinners2.default.dots12;
  }
}

const spinner = new Spinner();

exports.default = spinner;

/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = require("ora");

/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = require("cli-spinners");

/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = require("file-system");

/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = require("split-file");

/***/ }),
/* 16 */
/***/ (function(module, exports) {

module.exports = require("del");

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prepareDockerConfig = exports.getSupervisordFileContents = exports.getDockerfileContents = exports.getDependencyInstallScripts = exports.getDeps = exports.shouldIncludeMongo = exports.getDockerImage = undefined;

var _files = __webpack_require__(4);

var _logger = __webpack_require__(2);

var _logger2 = _interopRequireDefault(_logger);

var _constants = __webpack_require__(1);

var _meteor = __webpack_require__(3);

var _args = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

// get docker image version
const getDockerImage = exports.getDockerImage = () => {
  const dockerImage = (0, _args.getArg)('docker-image');
  if (dockerImage) {
    return dockerImage;
  }
  if (parseInt((0, _meteor.getMicroVersion)(), 10) < 4) {
    return 'nodesource/jessie:0.10.43';
  }
  return 'node:8.9.4';
};

// check if mongo url was passed as a env var
const shouldIncludeMongo = exports.shouldIncludeMongo = () => !(0, _args.getEnvironmentVariable)('MONGO_URL');

// get the value of --deps flag
const getDeps = exports.getDeps = () => (0, _args.getArg)('deps');

// construct the apt-get deps lines for the Dockerfile
const getDependencyInstallScripts = exports.getDependencyInstallScripts = (deps = getDeps('deps')) => {
  if (!deps) {
    return '';
  }
  const delimiter = deps.includes(',') ? ',' : ' ';
  return deps.split(delimiter).reduce((accumulator, currentValue) => `${accumulator}RUN apt-get install ${currentValue}\n`, '');
};

// construct the Dockerfile contents
const getDockerfileContents = exports.getDockerfileContents = (() => {
  var _ref = _asyncToGenerator(function* () {
    // check if user pass any --deps to install in the image
    const deps = getDeps();
    // get approriate docker image vesion
    const dockerImage = getDockerImage();
    // check to see if mogno should be included
    const includeMongo = shouldIncludeMongo();
    return `FROM ${dockerImage}
${deps ? getDependencyInstallScripts(deps) : ''}
${includeMongo ? `RUN apt-get update
RUN apt-get install -y mongodb
RUN apt-get install -y supervisor
VOLUME ["/data/db"]` : ''}
LABEL name="${_constants.projectName}"
COPY . /usr/src/app/
WORKDIR /usr/src/app
${!(0, _args.getArg)('nosplit') ? 'RUN cat *sf-part* > bundle.tar.gz' : ''}
RUN tar -xzf bundle.tar.gz
WORKDIR bundle/programs/server
RUN npm install
WORKDIR ../../
${includeMongo ? 'COPY supervisord.conf /etc/supervisor/supervisord.conf' : ''}
EXPOSE 3000
${includeMongo ? 'CMD ["supervisord"]' : 'CMD ["node", "main.js"]'}`;
  });

  return function getDockerfileContents() {
    return _ref.apply(this, arguments);
  };
})();

// construct the supervisord contents
const getSupervisordFileContents = exports.getSupervisordFileContents = () => `[supervisord]
nodaemon=true
loglevel=debug
[program:mongo]
command=mongod
[program:node]
command=node "/usr/src/app/bundle/main.js"`;

// prepares all docker related files
const prepareDockerConfig = exports.prepareDockerConfig = (() => {
  var _ref2 = _asyncToGenerator(function* () {
    try {
      _logger2.default.info('Preparing build');
      const dockerfileContents = yield getDockerfileContents();
      yield (0, _files.writeFile)(`${_constants.meteorNowBuildPath}/Dockerfile`, dockerfileContents);

      // if user did not pass MONGO_URL
      if (shouldIncludeMongo()) {
        _logger2.default.warn('WARNING: Did not pass a MONGO_URL. Bundling a NON-PRODUCTION version of MongoDB with your application. Read about the limitations here: https://git.io/vM72E');
        _logger2.default.warn('WARNING: It might take a few minutes for the app to connect to the bundled MongoDB instance after the deployment has completed.');
        _logger2.default.debug('creating supervisord.conf');
        // create a supervisord.conf file to run mongodb inside the container
        yield (0, _files.writeFile)(`${_constants.meteorNowBuildPath}/supervisord.conf`, getSupervisordFileContents());
      }
      _logger2.default.succeed();
    } catch (e) {
      // eslint-disable-next-line
      _logger2.default.error(e);
    }
  });

  return function prepareDockerConfig() {
    return _ref2.apply(this, arguments);
  };
})();

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deploy = exports.constructNowOptions = undefined;

var _process = __webpack_require__(5);

var _process2 = _interopRequireDefault(_process);

var _args = __webpack_require__(0);

var _meteor = __webpack_require__(3);

var _constants = __webpack_require__(1);

var _logger = __webpack_require__(2);

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

// construct an array of options to be passed to the now command
const constructNowOptions = exports.constructNowOptions = (() => {
  var _ref = _asyncToGenerator(function* () {
    // get list of all environment variables user passed with the -e flag
    const environmentVariables = yield (0, _args.getEnvironmentVariables)();
    // construct the ROOT_URL variable
    const rootUrl = (0, _args.getEnvironmentVariable)('ROOT_URL', environmentVariables) || 'http://localhost:3000';
    // construct the MONGO_URL variable
    const mongoUrl = (0, _args.getEnvironmentVariable)('MONGO_URL', environmentVariables) || 'mongodb://127.0.0.1:27017';

    const remainingVariables = (0, _args.getRemainingVariables)(environmentVariables);

    // options passed to the now cli tool. This array will be flattened
    // and will eventually be a string seperated by spaces.
    const options = [_constants.meteorNowBuildPath, ['--name', _constants.projectName], ['-e', 'PORT=3000'], ['-e', `ROOT_URL=${rootUrl}`], ['-e', `MONGO_URL=${mongoUrl}`], ...remainingVariables];
    // construct the METEOR_SETTINGS, first by checking if user passed
    // -e METEOR_SETTINGS='{ "foo": "bar" }' option to meteor-now
    let meteorSettings = (0, _args.getEnvironmentVariable)('METEOR_SETTINGS', environmentVariables);
    // if not, check if still no METEOR_SETTINGS exist
    if (!meteorSettings) {
      // check if NODE_ENV is passed and look for production.settings.json file
      meteorSettings = yield (0, _meteor.getMeteorSettings)();
    }
    if (meteorSettings) {
      options.push(['-e', `METEOR_SETTINGS='${meteorSettings}'`]);
    }

    // get any remaining custom flags passed in by user
    const remainingOptions = (0, _args.getRemainingOptions)();
    if (remainingOptions) {
      options.push(remainingOptions);
    }

    return options;
  });

  return function constructNowOptions() {
    return _ref.apply(this, arguments);
  };
})();

// deploy app with correct options
const deploy = exports.deploy = (() => {
  var _ref2 = _asyncToGenerator(function* () {
    try {
      _logger2.default.info('Deploying build (this can take several minutes)');
      const nowOptions = yield constructNowOptions();
      // spawn child process to execute now command. Flatten nowOptions
      // in order to properly pass all the options to now
      const deploymentUrl = yield (0, _process2.default)('now', (0, _args.flattenOptions)(nowOptions));
      _logger2.default.succeed();
      if (!(0, _args.isDebug)()) {
        _logger2.default.info(`App url is ${deploymentUrl}`);
        _logger2.default.succeed();
      }
    } catch (e) {
      _logger2.default.error('Something went wrong with now', e);
    }
  });

  return function deploy() {
    return _ref2.apply(this, arguments);
  };
})();

/***/ })
/******/ ]);